"""
Phase 6C: Audit Logging - Tamper-Proof Event Tracker
Comprehensive audit logging with HMAC signatures for tamper detection.
"""

from typing import Dict, Any, Optional, List
from datetime import datetime, timedelta
from dataclasses import dataclass
from enum import Enum
import hmac
import hashlib
import os
from supabase import Client


class AuditAction(str, Enum):
    """Audit event actions"""
    CREATE = "create"
    READ = "read"
    UPDATE = "update"
    DELETE = "delete"
    EXPORT = "export"
    LOGIN = "login"
    LOGOUT = "logout"
    INVITE = "invite"
    REVOKE = "revoke"


class RetentionPolicy(str, Enum):
    """Audit log retention policies"""
    STANDARD = "standard"  # 90 days
    EXTENDED = "extended"  # 1 year
    PERMANENT = "permanent"  # Forever


@dataclass
class AuditEvent:
    """Audit event model"""
    id: str
    org_id: str
    user_id: Optional[str]
    action: AuditAction
    resource_type: str
    resource_id: Optional[str]
    details: Dict[str, Any]
    ip_address: Optional[str]
    user_agent: Optional[str]
    signature: str
    previous_event_id: Optional[str]
    retention_policy: RetentionPolicy
    compliance_tags: List[str]
    created_at: datetime


class AuditLogger:
    """
    Tamper-proof audit logger.
    
    Features:
    - HMAC-SHA256 signatures for tamper detection
    - Event chaining (blockchain-style)
    - Compliance tagging (GDPR, SOC2, HIPAA)
    - Retention policies
    - Query and export capabilities
    """
    
    def __init__(self, supabase_client: Client, signature_secret: Optional[str] = None):
        """
        Initialize audit logger.
        
        Args:
            supabase_client: Supabase client
            signature_secret: Secret key for HMAC signatures (from env if not provided)
        """
        self.client = supabase_client
        self.signature_secret = signature_secret or os.getenv("AUDIT_SIGNATURE_SECRET")
        
        if not self.signature_secret:
            raise ValueError("AUDIT_SIGNATURE_SECRET required for audit logging")
    
    # ========================================
    # EVENT LOGGING
    # ========================================
    
    async def log_event(
        self,
        org_id: str,
        action: AuditAction,
        resource_type: str,
        user_id: Optional[str] = None,
        resource_id: Optional[str] = None,
        details: Optional[Dict[str, Any]] = None,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
        retention_policy: RetentionPolicy = RetentionPolicy.STANDARD,
        compliance_tags: Optional[List[str]] = None
    ) -> AuditEvent:
        """
        Log an audit event.
        
        Args:
            org_id: Organization ID
            action: Action performed
            resource_type: Type of resource (connector, user, setting, etc.)
            user_id: User who performed action (None for system events)
            resource_id: ID of affected resource
            details: Additional event details
            ip_address: IP address
            user_agent: User agent string
            retention_policy: How long to keep this event
            compliance_tags: Compliance frameworks (gdpr, soc2, hipaa)
        
        Returns:
            Created audit event
        """
        # Get previous event ID for chaining
        previous_event_id = await self._get_last_event_id(org_id)
        
        # Prepare event data
        event_data = {
            "org_id": org_id,
            "user_id": user_id,
            "action": action.value,
            "resource_type": resource_type,
            "resource_id": resource_id,
            "details": details or {},
            "ip_address": ip_address,
            "user_agent": user_agent,
            "previous_event_id": previous_event_id,
            "retention_policy": retention_policy.value,
            "compliance_tags": compliance_tags or []
        }
        
        # Insert event (signature will be auto-generated by trigger)
        response = self.client.table("audit_events").insert(event_data).execute()
        
        if not response.data:
            raise Exception("Failed to log audit event")
        
        event_dict = response.data[0]
        return self._dict_to_event(event_dict)
    
    async def log_login(
        self,
        org_id: str,
        user_id: str,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
        sso_provider: Optional[str] = None
    ) -> AuditEvent:
        """Log user login event"""
        details = {}
        if sso_provider:
            details["sso_provider"] = sso_provider
        
        return await self.log_event(
            org_id=org_id,
            action=AuditAction.LOGIN,
            resource_type="session",
            user_id=user_id,
            details=details,
            ip_address=ip_address,
            user_agent=user_agent,
            compliance_tags=["soc2", "gdpr"]
        )
    
    async def log_data_export(
        self,
        org_id: str,
        user_id: str,
        resource_type: str,
        export_format: str,
        record_count: int,
        ip_address: Optional[str] = None
    ) -> AuditEvent:
        """Log data export event (important for compliance)"""
        return await self.log_event(
            org_id=org_id,
            action=AuditAction.EXPORT,
            resource_type=resource_type,
            user_id=user_id,
            details={
                "export_format": export_format,
                "record_count": record_count
            },
            ip_address=ip_address,
            retention_policy=RetentionPolicy.EXTENDED,
            compliance_tags=["gdpr", "soc2", "hipaa"]
        )
    
    async def log_permission_change(
        self,
        org_id: str,
        user_id: str,
        target_user_id: str,
        old_role: str,
        new_role: str
    ) -> AuditEvent:
        """Log permission/role change (security critical)"""
        return await self.log_event(
            org_id=org_id,
            action=AuditAction.UPDATE,
            resource_type="user_role",
            user_id=user_id,
            resource_id=target_user_id,
            details={
                "old_role": old_role,
                "new_role": new_role
            },
            retention_policy=RetentionPolicy.PERMANENT,
            compliance_tags=["soc2"]
        )
    
    # ========================================
    # EVENT QUERIES
    # ========================================
    
    async def get_events(
        self,
        org_id: str,
        user_id: Optional[str] = None,
        action: Optional[AuditAction] = None,
        resource_type: Optional[str] = None,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
        limit: int = 100,
        offset: int = 0
    ) -> List[AuditEvent]:
        """
        Query audit events with filters.
        
        Args:
            org_id: Organization ID
            user_id: Filter by user
            action: Filter by action
            resource_type: Filter by resource type
            start_date: Filter from this date
            end_date: Filter to this date
            limit: Max results
            offset: Pagination offset
        
        Returns:
            List of audit events
        """
        query = self.client.table("audit_events").select("*").eq("org_id", org_id)
        
        if user_id:
            query = query.eq("user_id", user_id)
        
        if action:
            query = query.eq("action", action.value)
        
        if resource_type:
            query = query.eq("resource_type", resource_type)
        
        if start_date:
            query = query.gte("created_at", start_date.isoformat())
        
        if end_date:
            query = query.lte("created_at", end_date.isoformat())
        
        response = query.order("created_at", desc=True).range(offset, offset + limit - 1).execute()
        
        if not response.data:
            return []
        
        return [self._dict_to_event(event) for event in response.data]
    
    async def get_event(self, event_id: str) -> Optional[AuditEvent]:
        """Get specific audit event"""
        response = self.client.table("audit_events").select("*").eq("id", event_id).execute()
        
        if not response.data:
            return None
        
        return self._dict_to_event(response.data[0])
    
    async def get_user_activity(
        self,
        org_id: str,
        user_id: str,
        days: int = 30
    ) -> List[AuditEvent]:
        """Get recent activity for a user"""
        start_date = datetime.utcnow() - timedelta(days=days)
        
        return await self.get_events(
            org_id=org_id,
            user_id=user_id,
            start_date=start_date,
            limit=1000
        )
    
    async def get_resource_history(
        self,
        org_id: str,
        resource_type: str,
        resource_id: str,
        limit: int = 100
    ) -> List[AuditEvent]:
        """Get audit history for a specific resource"""
        response = self.client.table("audit_events").select("*").eq(
            "org_id", org_id
        ).eq("resource_type", resource_type).eq("resource_id", resource_id).order(
            "created_at", desc=True
        ).limit(limit).execute()
        
        if not response.data:
            return []
        
        return [self._dict_to_event(event) for event in response.data]
    
    # ========================================
    # TAMPER DETECTION
    # ========================================
    
    def verify_signature(self, event: AuditEvent) -> bool:
        """
        Verify event signature to detect tampering.
        
        Args:
            event: Audit event to verify
        
        Returns:
            True if signature is valid
        """
        # Reconstruct signature payload
        payload = f"{event.id}{event.org_id}{event.action}{event.resource_type}{event.created_at.isoformat()}"
        
        # Generate expected signature
        expected_signature = hmac.new(
            self.signature_secret.encode(),
            payload.encode(),
            hashlib.sha256
        ).hexdigest()
        
        return hmac.compare_digest(expected_signature, event.signature)
    
    async def verify_event_chain(
        self,
        org_id: str,
        start_event_id: Optional[str] = None,
        count: int = 100
    ) -> Dict[str, Any]:
        """
        Verify integrity of event chain (blockchain-style).
        
        Args:
            org_id: Organization ID
            start_event_id: Start from this event (None = latest)
            count: Number of events to verify
        
        Returns:
            Verification result with any tampered events
        """
        # Get events
        if start_event_id:
            event = await self.get_event(start_event_id)
            if not event:
                return {"valid": False, "error": "Start event not found"}
            
            events = await self.get_events(org_id, limit=count)
        else:
            events = await self.get_events(org_id, limit=count)
        
        tampered_events = []
        broken_chains = []
        
        for i, event in enumerate(events):
            # Verify signature
            if not self.verify_signature(event):
                tampered_events.append({
                    "event_id": event.id,
                    "reason": "Invalid signature"
                })
            
            # Verify chain (check if previous_event_id matches)
            if i < len(events) - 1:
                next_event = events[i + 1]
                if next_event.previous_event_id != event.id:
                    broken_chains.append({
                        "event_id": event.id,
                        "next_event_id": next_event.id,
                        "reason": "Chain broken"
                    })
        
        return {
            "valid": len(tampered_events) == 0 and len(broken_chains) == 0,
            "events_checked": len(events),
            "tampered_events": tampered_events,
            "broken_chains": broken_chains
        }
    
    # ========================================
    # EXPORT & COMPLIANCE
    # ========================================
    
    async def export_events(
        self,
        org_id: str,
        start_date: datetime,
        end_date: datetime,
        format: str = "json"
    ) -> Any:
        """
        Export audit events for compliance/archival.
        
        Args:
            org_id: Organization ID
            start_date: Start date
            end_date: End date
            format: Export format (json, csv)
        
        Returns:
            Exported events in specified format
        """
        events = await self.get_events(
            org_id=org_id,
            start_date=start_date,
            end_date=end_date,
            limit=10000  # High limit for export
        )
        
        if format == "json":
            return [self._event_to_dict(event) for event in events]
        elif format == "csv":
            # TODO: Implement CSV export
            raise NotImplementedError("CSV export not yet implemented")
        else:
            raise ValueError(f"Unsupported format: {format}")
    
    # ========================================
    # HELPER METHODS
    # ========================================
    
    async def _get_last_event_id(self, org_id: str) -> Optional[str]:
        """Get ID of most recent event for chaining"""
        response = self.client.table("audit_events").select("id").eq(
            "org_id", org_id
        ).order("created_at", desc=True).limit(1).execute()
        
        if response.data:
            return response.data[0]["id"]
        
        return None
    
    def _dict_to_event(self, data: Dict[str, Any]) -> AuditEvent:
        """Convert dict to AuditEvent"""
        return AuditEvent(
            id=data["id"],
            org_id=data["org_id"],
            user_id=data.get("user_id"),
            action=AuditAction(data["action"]),
            resource_type=data["resource_type"],
            resource_id=data.get("resource_id"),
            details=data.get("details", {}),
            ip_address=data.get("ip_address"),
            user_agent=data.get("user_agent"),
            signature=data["signature"],
            previous_event_id=data.get("previous_event_id"),
            retention_policy=RetentionPolicy(data.get("retention_policy", "standard")),
            compliance_tags=data.get("compliance_tags", []),
            created_at=datetime.fromisoformat(data["created_at"].replace("Z", "+00:00"))
        )
    
    def _event_to_dict(self, event: AuditEvent) -> Dict[str, Any]:
        """Convert AuditEvent to dict"""
        return {
            "id": event.id,
            "org_id": event.org_id,
            "user_id": event.user_id,
            "action": event.action.value,
            "resource_type": event.resource_type,
            "resource_id": event.resource_id,
            "details": event.details,
            "ip_address": event.ip_address,
            "user_agent": event.user_agent,
            "signature": event.signature,
            "previous_event_id": event.previous_event_id,
            "retention_policy": event.retention_policy.value,
            "compliance_tags": event.compliance_tags,
            "created_at": event.created_at.isoformat()
        }


# Example usage
"""
from services.audit.audit_logger import AuditLogger, AuditAction, RetentionPolicy

logger = AuditLogger(supabase_client)

# Log event
event = await logger.log_event(
    org_id="org-123",
    user_id="user-456",
    action=AuditAction.UPDATE,
    resource_type="connector",
    resource_id="conn-789",
    details={"changes": {"status": "active"}},
    ip_address="192.168.1.1",
    compliance_tags=["soc2"]
)

# Query events
events = await logger.get_events(
    org_id="org-123",
    action=AuditAction.DELETE,
    start_date=datetime(2026, 1, 1)
)

# Verify integrity
result = await logger.verify_event_chain("org-123", count=1000)
if not result["valid"]:
    print(f"Tampered events: {result['tampered_events']}")
"""
