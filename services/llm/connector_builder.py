"""
Custom Connector Builder

Generates Python adapter code from user configuration.
"""

from typing import Dict, List, Any, Optional
from pydantic import BaseModel
from datetime import datetime
import json


class ConnectorSpec(BaseModel):
    """Specification for custom connector"""
    name: str
    description: str
    api_base_url: str
    auth_type: str  # "api_key", "oauth2", "basic"
    endpoints: List[Dict[str, Any]]
    field_mappings: Dict[str, Dict[str, Any]]


class ConnectorBuilder:
    """
    Build custom connectors from specifications.
    
    Generates Python adapter code, tests, and documentation.
    """
    
    ADAPTER_TEMPLATE = '''"""
{description}

Auto-generated by Orion AI Connector Builder
Created: {timestamp}
"""

from typing import List, Dict, Any, Optional
from connectors.adapters.base import (
    BaseAdapter,
    AdapterConfig,
    AdapterCapability
)
from connectors.adapters.registry import register_adapter
from connectors.adapters.exceptions import (
    AuthenticationError,
    APIError
)
from connectors.unified_schema.customer import UnifiedCustomer


@register_adapter("{adapter_name}")
class {class_name}Adapter(BaseAdapter[UnifiedCustomer]):
    """
    {description}
    
    Auto-generated connector.
    """
    
    name = "{adapter_name}"
    version = "1.0.0"
    capabilities = {capabilities}
    
    BASE_URL = "{base_url}"
    
    def _get_auth_headers(self) -> dict[str, str]:
        """{auth_docstring}"""
{auth_implementation}
    
    async def to_unified(self, data: dict) -> UnifiedCustomer:
        """Transform API response to unified customer"""
{to_unified_implementation}
    
    async def from_unified(self, model: UnifiedCustomer) -> dict:
        """Transform unified customer to API format"""
{from_unified_implementation}
    
    async def list_customers(
        self,
        limit: int = 100
    ) -> List[UnifiedCustomer]:
        """List customers from API"""
        if not self._client:
            await self.connect()
        
        try:
            response = await self._client.get(
                f"{{self.BASE_URL}}{list_endpoint}",
                params={{"limit": limit}}
            )
            response.raise_for_status()
            data = response.json()
            
            return [
                await self.to_unified(record)
                for record in data.get("{response_key}", [])
            ]
        
        except Exception as e:
            raise APIError(
                f"Failed to list customers: {{str(e)}}",
                status_code=getattr(e, "status_code", None)
            )
    
    async def create_customer(
        self,
        customer: UnifiedCustomer
    ) -> UnifiedCustomer:
        """Create customer in API"""
        if not self._client:
            await self.connect()
        
        payload = await self.from_unified(customer)
        
        try:
            response = await self._client.post(
                f"{{self.BASE_URL}}{create_endpoint}",
                json=payload
            )
            response.raise_for_status()
            return await self.to_unified(response.json())
        
        except Exception as e:
            raise APIError(
                f"Failed to create customer: {{str(e)}}",
                status_code=getattr(e, "status_code", None)
            )
'''
    
    TEST_TEMPLATE = '''"""
Tests for {class_name}Adapter

Auto-generated tests.
"""

import pytest
from connectors.adapters.{adapter_name} import {class_name}Adapter


@pytest.fixture
def adapter():
    """Create adapter instance"""
    return {class_name}Adapter(
        config={{"credentials": {test_credentials}}}
    )


def test_adapter_registration(adapter):
    """Test adapter is registered"""
    assert adapter.name == "{adapter_name}"
    assert adapter.version == "1.0.0"


def test_capabilities(adapter):
    """Test adapter capabilities"""
    assert {class_name}Adapter.capabilities == {capabilities}


@pytest.mark.asyncio
async def test_to_unified(adapter):
    """Test transformation to unified schema"""
    sample_data = {sample_data}
    
    unified = await adapter.to_unified(sample_data)
    
    assert unified.source_system == "{adapter_name}"
    assert unified.email is not None
    assert unified.name is not None


@pytest.mark.asyncio
async def test_from_unified(adapter):
    """Test transformation from unified schema"""
    from connectors.unified_schema.customer import UnifiedCustomer
    
    customer = UnifiedCustomer(
        source_system="{adapter_name}",
        email="test@example.com",
        name="Test User"
    )
    
    api_format = await adapter.from_unified(customer)
    
    assert isinstance(api_format, dict)
    assert "email" in str(api_format).lower() or "mail" in str(api_format).lower()
'''
    
    def __init__(self, llm_client=None):
        """
        Initialize connector builder.
        
        Args:
            llm_client: Optional LLM for intelligent code generation
        """
        self.llm = llm_client
    
    def generate_adapter_code(
        self,
        spec: ConnectorSpec
    ) -> str:
        """
        Generate Python adapter code from specification.
        
        Args:
            spec: Connector specification
        
        Returns:
            Generated Python code
        """
        # Generate class name
        class_name = "".join(
            word.capitalize() for word in spec.name.split("_")
        )
        
        # Determine capabilities
        capabilities = ["AdapterCapability.READ", "AdapterCapability.WRITE"]
        if spec.auth_type == "oauth2":
            capabilities.append("AdapterCapability.WEBHOOK")
        
        # Generate auth implementation
        auth_impl, auth_doc = self._generate_auth_code(spec.auth_type)
        
        # Generate transformation implementations
        to_unified_impl = self._generate_to_unified(spec.field_mappings)
        from_unified_impl = self._generate_from_unified(spec.field_mappings)
        
        # Find list and create endpoints
        list_endpoint = "/customers"
        create_endpoint = "/customers"
        response_key = "data"
        
        for endpoint in spec.endpoints:
            if endpoint.get("operation") == "list":
                list_endpoint = endpoint["path"]
                response_key = endpoint.get("response_key", "data")
            elif endpoint.get("operation") == "create":
                create_endpoint = endpoint["path"]
        
        # Generate code
        code = self.ADAPTER_TEMPLATE.format(
            description=spec.description,
            timestamp=datetime.utcnow().isoformat(),
            adapter_name=spec.name,
            class_name=class_name,
            capabilities=capabilities,
            base_url=spec.api_base_url,
            auth_docstring=auth_doc,
            auth_implementation=auth_impl,
            to_unified_implementation=to_unified_impl,
            from_unified_implementation=from_unified_impl,
            list_endpoint=list_endpoint,
            create_endpoint=create_endpoint,
            response_key=response_key
        )
        
        return code
    
    def _generate_auth_code(self, auth_type: str) -> tuple[str, str]:
        """Generate authentication code based on type"""
        if auth_type == "api_key":
            return (
                '''        api_key = self.credentials.get("api_key", "")
        if not api_key:
            raise AuthenticationError("API key not provided")
        
        return {
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        }''',
                "Get API key authentication headers"
            )
        
        elif auth_type == "oauth2":
            return (
                '''        access_token = self.credentials.get("access_token", "")
        if not access_token:
            raise AuthenticationError("OAuth access token not provided")
        
        return {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }''',
                "Get OAuth 2.0 authentication headers"
            )
        
        elif auth_type == "basic":
            return (
                '''        username = self.credentials.get("username", "")
        password = self.credentials.get("password", "")
        if not username or not password:
            raise AuthenticationError("Username and password required")
        
        import base64
        credentials = base64.b64encode(f"{username}:{password}".encode()).decode()
        
        return {
            "Authorization": f"Basic {credentials}",
            "Content-Type": "application/json"
        }''',
                "Get Basic authentication headers"
            )
        
        else:
            return (
                '''        return {"Content-Type": "application/json"}''',
                "Get headers (no authentication)"
            )
    
    def _generate_to_unified(self, field_mappings: Dict[str, Dict[str, Any]]) -> str:
        """Generate to_unified transformation code"""
        lines = ["        return UnifiedCustomer("]
        lines.append('            source_system=self.name,')
        lines.append('            source_id=str(data.get("id", "")),')
        
        for unified_field, mapping in field_mappings.items():
            source_path = mapping["source_path"]
            
            if unified_field == "email":
                lines.append(f'            email=data.get("{source_path}", "unknown@example.com"),')
            elif unified_field == "name":
                lines.append(f'            name=data.get("{source_path}", "Unknown"),')
            elif unified_field == "phone":
                lines.append(f'            phone=data.get("{source_path}"),')
            elif unified_field == "company":
                lines.append(f'            company=data.get("{source_path}"),')
            elif unified_field == "billing_address":
                # Generate address mapping
                lines.append('            billing_address={')
                lines.append('                "source_system": self.name,')
                lines.append('                "source_id": str(data.get("id", "")),')
                lines.append(f'                "street": data.get("{source_path}.street"),')
                lines.append(f'                "city": data.get("{source_path}.city"),')
                lines.append(f'                "state": data.get("{source_path}.state"),')
                lines.append(f'                "postal_code": data.get("{source_path}.postal_code"),')
                lines.append(f'                "country": data.get("{source_path}.country")')
                lines.append('            } if data.get("address") else None,')
        
        lines.append('            raw_data=data')
        lines.append('        )')
        
        return "\n".join(lines)
    
    def _generate_from_unified(self, field_mappings: Dict[str, Dict[str, Any]]) -> str:
        """Generate from_unified transformation code"""
        lines = ["        data = {}"]
        lines.append('')
        
        for unified_field, mapping in field_mappings.items():
            source_path = mapping["source_path"]
            
            if unified_field in ["email", "name"]:
                lines.append(f'        data["{source_path}"] = str(model.{unified_field})')
            elif unified_field in ["phone", "company"]:
                lines.append(f'        if model.{unified_field}:')
                lines.append(f'            data["{source_path}"] = model.{unified_field}')
        
        lines.append('')
        lines.append('        return data')
        
        return "\n".join(lines)
    
    def generate_tests(
        self,
        spec: ConnectorSpec,
        sample_data: dict
    ) -> str:
        """
        Generate test file for adapter.
        
        Args:
            spec: Connector specification
            sample_data: Sample API response for tests
        
        Returns:
            Generated test code
        """
        class_name = "".join(
            word.capitalize() for word in spec.name.split("_")
        )
        
        # Generate test credentials based on auth type
        if spec.auth_type == "api_key":
            test_creds = '{"api_key": "test_key_123"}'
        elif spec.auth_type == "oauth2":
            test_creds = '{"access_token": "test_token_123"}'
        elif spec.auth_type == "basic":
            test_creds = '{"username": "test", "password": "test123"}'
        else:
            test_creds = '{}'
        
        capabilities = ["AdapterCapability.READ", "AdapterCapability.WRITE"]
        
        return self.TEST_TEMPLATE.format(
            class_name=class_name,
            adapter_name=spec.name,
            test_credentials=test_creds,
            capabilities=capabilities,
            sample_data=json.dumps(sample_data, indent=4)
        )
    
    def generate_readme(self, spec: ConnectorSpec) -> str:
        """
        Generate README documentation.
        
        Args:
            spec: Connector specification
        
        Returns:
            Markdown documentation
        """
        return f"""# {spec.name.title()} Connector

{spec.description}

**Auto-generated by Orion AI Connector Builder**

## Configuration

### Authentication

Type: `{spec.auth_type}`

Required credentials:
{self._get_required_credentials(spec.auth_type)}

### Endpoints

{self._format_endpoints(spec.endpoints)}

## Usage

```python
from connectors.adapters.{spec.name} import {spec.name.title().replace('_', '')}Adapter

adapter = {spec.name.title().replace('_', '')}Adapter(
    config={{
        "credentials": {{
            # Your credentials here
        }}
    }}
)

# List customers
customers = await adapter.list_customers(limit=50)

# Create customer
new_customer = await adapter.create_customer(customer_data)
```

## Field Mappings

| Unified Field | API Field | Transformation |
|---------------|-----------|----------------|
{self._format_mappings(spec.field_mappings)}

## Generated

- Created: {datetime.utcnow().isoformat()}
- Version: 1.0.0
"""
    
    def _get_required_credentials(self, auth_type: str) -> str:
        """Get required credentials for auth type"""
        if auth_type == "api_key":
            return "- `api_key`: API key from provider"
        elif auth_type == "oauth2":
            return "- `access_token`: OAuth 2.0 access token\n- `refresh_token`: OAuth 2.0 refresh token"
        elif auth_type == "basic":
            return "- `username`: Account username\n- `password`: Account password"
        else:
            return "- No authentication required"
    
    def _format_endpoints(self, endpoints: List[Dict[str, Any]]) -> str:
        """Format endpoints list"""
        lines = []
        for endpoint in endpoints:
            lines.append(f"- `{endpoint.get('method', 'GET')} {endpoint['path']}`: {endpoint.get('description', 'No description')}")
        return "\n".join(lines) if lines else "No endpoints configured"
    
    def _format_mappings(self, field_mappings: Dict[str, Dict[str, Any]]) -> str:
        """Format field mappings table"""
        lines = []
        for unified_field, mapping in field_mappings.items():
            transform = mapping.get("transformation") or "None"
            lines.append(f"| `{unified_field}` | `{mapping['source_path']}` | `{transform}` |")
        return "\n".join(lines) if lines else "No mappings configured"
